# The MIT License (MIT)
#
# .mem file parser for mcs51 target generated by sdcc linker
# tested with SDCC 3.8.0
#
# For parser to work correctly linker must have memory sizes passed as parameters,
# for example, for Nuvoton N76E003:
#   LDFLAGS += --iram-size 256 --xram-size 768 --code-size 18432
# and idata used for stack
#
#  > size-mcs51.py main.mem
#
# will output
#
#   Name              Start    End  Size   Max Spare
#   ---------------- ------ ------ ----- ----- -----------
#   REG BANKS        0x0000 0x001F     4     4     0
#   IDATA            0x0000 0x0033    52   256   204
#   OVERLAYS                           2
#   STACK            0x0034 0x00FF   204   248   204
#   EXTERNAL RAM     0x0001 0x0049    73   768   695 90.5% free
#   ROM/EPROM/FLASH  0x0000 0x0567  1384 18432 17048 92.5% free

import sys

# must be called with a .mem file as the command line argument
# tested with sdcc 3.8.0/python 3.7.2
# change *_LINE constants below in case if .mem file format changes

RAM_LINE   = 2
XRAM_LINE  = 27
ROM_LINE   = 28

# default idata size for MCS 51
IDATA_MAX = 256
# max 4 reg banks for MCS 51
BANKS_MAX = 4
# assume that stack uses idata and starts right after the first register bank
STACK_MAX = IDATA_MAX - 8

if (len(sys.argv) != 2):
    print('Usage: size-mcs51.py file.mem ')
    sys.exit()

try:
    file = open(sys.argv[1])
except IOError:
    print('Could not read file:', sys.argv[1])
    sys.exit()

lines = file.readlines()
file.close()

# ram will hold the string with the RAM layout
ram = ''
# read layout in the ram - extract only relevant bytes
for i in range(RAM_LINE, RAM_LINE + 16):
    ram += lines[i][5:37]

# count reg banks, bank 0 always in use
banks = 1
# get the max index of the used reg bank
if ram.count('|3'):
    banks = 4
elif ram.count('|2'):
    banks = 3
elif ram.count('|1'):
    banks = 2
# count overlays
overlays = ram.count('|Q')
# count stack bytes
stack = ram.count('|S')
# used idata
idata = IDATA_MAX - stack

print('')
print('   Name              Start    End  Size   Max Spare')
print('   ---------------- ------ ------ ----- ----- -----------')
# registers banks
print('   REG BANKS        0x0000 0x' + format(int(banks*8)-1, '04X'), '', end='')
print(format(banks, '5d'), format(BANKS_MAX, '5d'), '', end='')
print(format(BANKS_MAX - banks, '5d'))
# DATA line
print('   IDATA            0x0000 0x' + format(int(idata)-1, '04X'), '', end='')
print(format(idata, '5d'), format(IDATA_MAX, '5d'), '', end='')
print(format(IDATA_MAX - idata, '5d'))
# OVERLAYS line
if overlays:
    print('   OVERLAYS                          ', overlays)
# STACK line
print('   STACK            0x' + format(int(idata), '04X'), '0x00FF ', end='')
print(format(stack, '5d'), format(STACK_MAX, '5d'), format(stack, '5d'))
# EXTERNAL RAM line
list = lines[XRAM_LINE].split()
print('  ', list[0], list[1], '   ', list[2], list[3], '', end='')
print(format(int(list[4]), '5d'), format(int(list[5]), '5d'), '', end='')
spare = int(list[5]) - int(list[4])
print(format(spare, '5d'), format(100.0*float(spare)/float(list[5]), '.1f')+'% free')
# ROM/EPROM/FLASH line
list = lines[ROM_LINE].split()
print('  ', list[0], '', list[1], list[2], '', end='')
print(format(int(list[3]), '5d'), format(int(list[4]), '5d'), '', end='')
spare = int(list[4]) - int(list[3])
print(format(spare, '5d'), format(100.0*float(spare)/float(list[4]), '.1f')+'% free')